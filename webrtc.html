<!DOCTYPE html>
<html>

<head>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        .hidden {
            visibility: hidden;
            display: none;
        }
    </style>
</head>

<body>
    <div id="host" class="hidden setup">
        <div>
            <a href="#" id="connectionURL">Connection URL</a>
        </div>
        <form id="connectForm">
            <input type="text" id="connect"><br>
            <input type="submit">
        </form>
    </div>
    <div id="guest" class="hidden setup">
        <button onclick="javascript:copyConnection()">Copy Connection String</button>
    </div>
    <div id="app" class="hidden">
        <pre id="chat"></pre>
        <form id="chatForm">
            <input type="text" id="chatToSend"><br>
            <input type="submit">
        </form>
    </div>
    <script>
        function WebRTCConnection(role) {
            const configuration = {'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]};
            this.connection = new RTCPeerConnection(configuration);

            this.info = {
                o : '',
                a : '',
                i : []
            };
            
            this.onAddIceCandidate = async (event) => {
                if (event.candidate != null)
                {
                    const candidateJson = JSON.stringify(event.candidate.toJSON());
                    console.log(`icecandidate: ${candidateJson}`);

                    this.info.i.push(candidateJson);
                }
            };
            this.connection.onicecandidate = this.onAddIceCandidate;

            this.onChannelStateChange = () => {
                const readyState = this.channel.readyState;
                console.log('Channel state is: ' + readyState);

                if (readyState == 'open')
                {
                    window.dispatchEvent(new Event('connectionready'));
                }
            }
            this.onChannelMessageCallback = (event) => {
                console.log('Received Message: ' + event.data);

                window.dispatchEvent(new CustomEvent('connectiondatareceived', {
                    detail : {
                        text: event.data
                    }
                }));
            }

            this.addIceCandidate = async (candidate) => {
                try {
                    this.connection.addIceCandidate(candidate);
                } catch {
                    console.log("Failed to add candidate");
                }
            }
            this.sendData = (data) => {
                this.channel.send(data);
                console.log('Sent Data: ' + data);
            }

            if (role == 'host')
            {
                this.channel = this.connection.createDataChannel('sendDataChannel');
                this.channel.onmessage = this.onChannelMessageCallback;
                this.channel.onopen = this.onChannelStateChange;
                this.channel.onclose = this.onChannelStateChange;

                this.connectToGuest = async (answer) => {
                    this.connection.setRemoteDescription(answer);
                }

                const createOffer = async () => {
                    const offer = await this.connection.createOffer();
                    this.connection.setLocalDescription(offer);

                    const offerJson = JSON.stringify(offer);
                    console.log(`offer: ${offerJson}`);

                    this.info.o = offerJson;
                }
                createOffer();
            }
            else if (role == 'guest')
            {
                this.channelCallback = (event) => {
                    console.log('Receive Channel Callback');
                    this.channel = event.channel;
                    this.channel.onmessage = this.onChannelMessageCallback;
                    this.channel.onopen = this.onChannelStateChange;
                    this.channel.onclose = this.onChannelStateChange;
                }
                this.connection.ondatachannel = this.channelCallback;

                this.connectToHost = async (offer) => {
                    this.connection.setRemoteDescription(offer);
                    const answer = await this.connection.createAnswer();
                    this.connection.setLocalDescription(answer);

                    const answerJson = JSON.stringify(answer);
                    console.log(`answer: ${answerJson}`);

                    this.info.a = answerJson;
                };
            }
        }

        var urlParams = new URLSearchParams(window.location.search);

        var connection;
        if (urlParams.has('connect'))
        {
            document.getElementById("guest").classList.remove('hidden');

            connection = new WebRTCConnection('guest');

            var encodedInfo = urlParams.get('connect');
            var info = JSON.parse(atob(encodedInfo));

            connection.connectToHost(JSON.parse(info.o));
            info.i.forEach(iceCandidate => {
                connection.addIceCandidate(JSON.parse(iceCandidate));
            });

            function copyConnection(event) {
                var info = connection.info;
                var infoJson = JSON.stringify(info);
                var encodedInfo = btoa(infoJson);

                // https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f
                const el = document.createElement('textarea');
                el.value = encodedInfo;
                el.setAttribute('readonly', '');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
                document.body.appendChild(el);
                el.select();
                document.execCommand('copy');
                document.body.removeChild(el);
            }
        }
        else
        {
            document.getElementById("host").classList.remove('hidden');
            document.getElementById("connectForm").addEventListener('submit', event => {
                event.preventDefault();

                const encodedInfo = document.getElementById("connect").value;

                var info = JSON.parse(atob(encodedInfo));
                connection.connectToGuest(JSON.parse(info.a));
                info.i.forEach(iceCandidate => {
                    connection.addIceCandidate(JSON.parse(iceCandidate));
                });
            });

            connection = new WebRTCConnection('host');

            setTimeout(() => {
                var info = connection.info;
                var infoJson = JSON.stringify(info);
                var encodedInfo = btoa(infoJson);
                
                const url = window.location.href + `?connect=${encodedInfo}`;
                const connectionURL = document.getElementById("connectionURL");
                connectionURL.href = url;
            }, 200);

            const connect = (encodedInfo) => {
                var info = JSON.parse(atob(encodedInfo));

                connection.connectToGuest(JSON.parse(info.a));
                info.i.forEach(iceCandidate => {
                    connection.addIceCandidate(JSON.parse(iceCandidate));
                });
            };
        }

        window.addEventListener('connectionready', () => {
            Array.from(document.getElementsByClassName('setup')).forEach(element => {
                element.classList.add('hidden');
            });
            document.getElementById("app").classList.remove('hidden');

            window.addEventListener('connectiondatareceived', (event) => {
                document.getElementById("chat").innerText += 'Them: ' +event.detail.text + '\n';
            });

            document.getElementById("chatForm").addEventListener('submit', event => {
                event.preventDefault();

                const chatToSend = document.getElementById("chatToSend");
                const text = chatToSend.value;

                document.getElementById("chat").innerText += 'You: ' + text + '\n';
                connection.sendData(text);

                chatToSend.value = '';
            })
        });
    </script>
</body>

</html>